<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Hexo
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 7.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">bamboo</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >您需要的前端面试算法(上)</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="阅前说明"><a href="#阅前说明" class="headerlink" title="阅前说明"></a>阅前说明</h2><blockquote>
<p>文章将会分成上中下三部分，包含一些常见面试算法题，大部分算法题来自于《剑指offer》,在此对此书的作者及牛客编程网表示感谢,还有一部分来自于本人的收集。题目解法有多种，望大虾多多评论探讨或指正</p>
</blockquote>
<h2 id="1、数组遍历"><a href="#1、数组遍历" class="headerlink" title="1、数组遍历"></a>1、数组遍历</h2><blockquote>
<p>题述： 一个数组中，每一行都按照从左至右递增的顺序排序，每一列按照从上到下递增的顺序排序。完成：输入一个这样的二维数组和一个整数，判断数组是否含有这个整数</p>
</blockquote>
<blockquote>
<p>思路：数组是有序的，可以根据规律减少遍历次数。从右上角开始遍历，如果这个数不等，那么可以根据目标数与这个数的大小可以去掉一些行&#x2F;列的遍历</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function findNumInSortedArray(arr, num) &#123;</span><br><span class="line">  if (!Array.isArray(arr) || typeof num != &#x27;number&#x27; || isNaN(num)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  let rows = arr.length;</span><br><span class="line">  let columns = arr[0].length;</span><br><span class="line">  let row = 0;</span><br><span class="line">  let column = columns -1;</span><br><span class="line"></span><br><span class="line">  while(row &lt; rows &amp;&amp; column &gt;=0 )&#123;</span><br><span class="line">    if (arr[row][column] == num) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else if (arr[row][column] &gt; num) &#123;</span><br><span class="line">      column --;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      row ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、字符串替换"><a href="#2、字符串替换" class="headerlink" title="2、字符串替换"></a>2、字符串替换</h2><blockquote>
<p>题述：实现一个函数,将字符串中的每个空格替换成%20。如输入’we arr happy’, 则输出’we%20are%20happy’</p>
</blockquote>
<blockquote>
<p>思路：可以使用正则替换与遍历替换两种方式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//使用正则</span><br><span class="line">function replaceStr(str)&#123;</span><br><span class="line">  if (typeof str !== &#x27;string&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;str is not string&#x27;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  return str.replace(/\s/g, &#x27;%20&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用遍历替换,需要遍历str，识别空格然后替换字符串</span><br><span class="line">function replaceStr2(str) &#123;</span><br><span class="line">  if (typeof str !== &#x27;string&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;str is not string&#x27;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  let strArr = [];</span><br><span class="line">  let len = str.length;</span><br><span class="line">  let i = 0;</span><br><span class="line">  while(i &lt; len) &#123;</span><br><span class="line">    if (str[i] === &#x27; &#x27; ) &#123;</span><br><span class="line">      strArr[i] = &#x27;%20&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      strArr[i] = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return strArr.join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、链表逆序打印"><a href="#3、链表逆序打印" class="headerlink" title="3、链表逆序打印"></a>3、链表逆序打印</h2><blockquote>
<p>题述：输入一个链表的头结点，从尾到头打印每个节点的值</p>
</blockquote>
<blockquote>
<p>思路：可以将链表翻转，再打印，但会破坏链表的结构。还可以用栈存储节点，然后打印</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function displayLinkList(head) &#123;</span><br><span class="line">  let stack = [];</span><br><span class="line">  let node = head;</span><br><span class="line">  while(node) &#123;</span><br><span class="line">    stack.push(node);</span><br><span class="line">    node = node.next;</span><br><span class="line">  &#125;</span><br><span class="line">  for (let len = stack.length - 1; len &gt;=0 ; len--) &#123;</span><br><span class="line">    console.log(stack[i].ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、重建二叉树"><a href="#4、重建二叉树" class="headerlink" title="4、重建二叉树"></a>4、重建二叉树</h2><blockquote>
<p>题述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<blockquote>
<p>思路：在二叉树的前序遍历中，第一个数字总是树的根节点的值，在中序遍历中，根结点的值在序列的中间。找根节点，确定左右子树，然后递归循环，关键是依次挂载’根’节点（确定其在左还是右）。前序确定根节点，中序确定左右节点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//节点定义</span><br><span class="line"> function TreeNode(ele) &#123;</span><br><span class="line">   this.ele = ele;</span><br><span class="line">   this.right = null;</span><br><span class="line">   this.left = null;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function constructBinaryTree(preOrders, inOrders) &#123;</span><br><span class="line">  if (!inOrders.length) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  let rootIndex = 0;</span><br><span class="line">  let l_preOrders = [];</span><br><span class="line">  let l_inOrders = [];</span><br><span class="line">  let r_preOrders = [];</span><br><span class="line">  let r_inOrders = [];</span><br><span class="line">  //确定根节点</span><br><span class="line">  let head = new TreeNode(preOrders[0]);</span><br><span class="line">  for (let i = 0; i &lt; inOrders.length; i++ ) &#123;</span><br><span class="line">    if (preOrders[0] === inOrders[i]) &#123;</span><br><span class="line">      rootIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //确定左右子节点树</span><br><span class="line">  for (let i = 0; i &lt; rootIndex; i++) &#123;</span><br><span class="line">    l_preOrders.push(preOrders[ i + 1]);</span><br><span class="line">    l_inOrders.push(inOrders[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (let i = rootIndex + 1; i &lt; inOrders.length; i ++ ) &#123;</span><br><span class="line">    r_preOrders.push(preOrders[i]);</span><br><span class="line">    r_inOrders.push(inOrders[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  head.left = constructBinaryTree(l_preOrders, l_inOrders);</span><br><span class="line">  head.right = constructBinaryTree(r_preOrders, r_inOrders);</span><br><span class="line"></span><br><span class="line">  return head;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function getTreeFromPreInOrders(preOrders, inOrders) &#123;</span><br><span class="line">  if (Array.isArray(preOrders) &amp;&amp; Array.isArray(inOrders)) &#123;</span><br><span class="line">    return constructBinaryTree(preOrders, inOrders);</span><br><span class="line">  &#125;</span><br><span class="line">  console.error(&#x27;preOrders or inOrders is no Array&#x27;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、栈与队列的互相实现"><a href="#5、栈与队列的互相实现" class="headerlink" title="5、栈与队列的互相实现"></a>5、栈与队列的互相实现</h2><blockquote>
<p>栈：先进后出， 队列：先进先出</p>
</blockquote>
<ul>
<li><blockquote>
<p>题述：用两个栈实现队列</p>
</blockquote>
<blockquote>
<p>思路：栈a的数据全部依次放到栈b,那么原先早进入栈a的数据会出现在栈b栈顶的位置， 那么队列的出队，相当于栈b的出栈，队列的入队，相当于栈a的入栈。当栈b为空时，将栈a的数据全部出栈到栈b</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let stack_a = [];</span><br><span class="line">let stack_b = [];</span><br><span class="line"></span><br><span class="line">function push (node ) &#123;</span><br><span class="line">  stack_a.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function pop () &#123;</span><br><span class="line">  if (stack_b.length === 0 ) &#123;</span><br><span class="line">    for (let i = 0, len = stack_a.length; i &lt; len; i ++ ) &#123;</span><br><span class="line">      stack_b.push(stack_a.pop());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return stack_b.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>题述：使用两个队列实现栈</p>
</blockquote>
<blockquote>
<p>思路：两个队列，拿一个队列做存储区，有数据的队列依次出队数据到缓存队列，那么当有数据的队列出到最后一个数据时，即是需要出栈的数据。入栈的数据入队到有数据的队列,如果两个为空，任取一个入队</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let queue_a = [];</span><br><span class="line">let queue_b = [];</span><br><span class="line"></span><br><span class="line">function push(node) &#123;</span><br><span class="line"> if (queue_a.length &amp;&amp; queue_b.length) &#123;</span><br><span class="line">   return console.log(&#x27;wrong !&#x27;);</span><br><span class="line"> &#125;</span><br><span class="line"> if (queue_a.length) &#123;</span><br><span class="line">   queue_a.push(node);</span><br><span class="line"> &#125; else if (queue_b.length) &#123;</span><br><span class="line">   queue_b.push(node);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   queue_a.push(node);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function pop() &#123;</span><br><span class="line"> if (queue_a.length &amp;&amp; !queue_b.length) &#123;</span><br><span class="line">   for (let i = 0, len = queue_a.length; i &lt; len; i++) &#123;</span><br><span class="line">     if (i == len -1) &#123;</span><br><span class="line">       return queue_a.shift();</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       queue_b.push(queue_a.shift());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; else if (!queue_a.length &amp;&amp; queue_b.length) &#123;</span><br><span class="line">   for (let i = 0, len = queue_b.length; i &lt; len; i++) &#123;</span><br><span class="line">     if (i == len -1) &#123;</span><br><span class="line">       return queue_b.shift();</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       queue_a.push(queue_b.shift());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; else if (queue_a.length &amp;&amp; queue_b.length) &#123;</span><br><span class="line">   console.log(&#x27;wrong!&#x27;);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   return null;</span><br><span class="line"> &#125;</span><br><span class="line"> return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、旋转数组的最小数字"><a href="#6、旋转数组的最小数字" class="headerlink" title="6、旋转数组的最小数字"></a>6、旋转数组的最小数字</h2><blockquote>
<p>题述：把一个数字最开始的若干个元素搬到数组的末尾，称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1</p>
</blockquote>
<blockquote>
<p>思路：递增有序找最值，可以尝试二分法。数组第一个元素肯定会比最后一个元素大，选择中间元素，与末尾元素比较，如果大于末尾元素则表示最小元素在右区间，否则在左区间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function findMinFromRotateArr(arr) &#123;</span><br><span class="line">  if (!Array.isArray(arr)) &#123;</span><br><span class="line">    return console.error(&#x27;wrong!&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  let start = 0;</span><br><span class="line">  let end = arr.length - 1;</span><br><span class="line">  while((end - start) &gt; 1) &#123;</span><br><span class="line">    let mid = Math.floor(((end + start)) / 2) ;</span><br><span class="line">    if (arr[mid] &gt;= arr[end]) &#123;</span><br><span class="line">      start = mid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return arr[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、斐波那契数列"><a href="#7、斐波那契数列" class="headerlink" title="7、斐波那契数列"></a>7、斐波那契数列</h2><blockquote>
<p>题述：当n &#x3D; 0,f(n) &#x3D; 0;当n &#x3D; 1, f(n) &#x3D; 1;当n &gt; 1, f(n) &#x3D; f(n-1) + f(n-2)。现在要求输入一个整数n，请你输出斐波那契数列的第n项</p>
</blockquote>
<blockquote>
<p>思路：斐波那契数列是一个经典数学题。可以采用递归与循环方式解决，注意递归下，如果n比较大时，会产生很大内存消耗</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//递归解法</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">  if (n &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(n == 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return fibonacci(n - 2) + fibonacci(n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//循环解法</span><br><span class="line">function fabonacci(n) &#123;</span><br><span class="line">  if (n &lt;= 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(n == 1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;;</span><br><span class="line">  let fn_2 = 0;</span><br><span class="line">  let fn_1 = 1;</span><br><span class="line">  let fn = 0;</span><br><span class="line">  for (let i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    fn = fn_1 + fn_2;</span><br><span class="line">    fn_2 = fn_1;</span><br><span class="line">    fn_1 = fn;</span><br><span class="line">  &#125;</span><br><span class="line">  return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>斐波那契变题1<br>题述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<blockquote>
<p>思路：n个台阶跳法-&gt; f(n), 假如其第一次跳一级，那么接下来是跳法是f(n-1),假如第一次跳2级，那么跳法是f(n-2)。那么f(n) &#x3D; f(n-1) + f(n-2),就是一个斐波那契数列</p>
</blockquote>
</li>
<li><blockquote>
<p>斐波那契变题2<br>题述：题述:[] 这是 2x1的矩形，可以横着或者竖着摆放，那么其覆盖 8*2x1这样的小矩形有多少种摆法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//大矩形：[][][][][][][][]</span><br><span class="line">//       [][][][][][][][]                                                        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：如果竖着摆，那么会占去1列，如果横着摆，一种摆法会占去2列，那么从8列的矩形，第一次摆放的时候，要么竖着摆，接着覆盖7列矩形，要么横着摆，接着覆盖6列矩形。从而可以抽象成 f(8) &#x3D; f(7) + f(6)。还是一个斐波那契问题</p>
</blockquote>
</li>
</ul>
<h2 id="8、位运算"><a href="#8、位运算" class="headerlink" title="8、位运算"></a>8、位运算</h2><blockquote>
<p>js中的位运算：&amp;(与), |(或) , ~(非) ,^(异或), &lt;&lt;(左移), &gt;&gt;(右移), &gt;&gt;&gt;(无符号右移)</p>
</blockquote>
<ul>
<li><blockquote>
<p>题述:输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<blockquote>
<p>思路：可以使用右移与位与运算。判断整数的二进制数的最右侧数是不是1(和1与),然后右移，直至为0</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//缺陷版：</span><br><span class="line">//缺陷在于不能针对负数情况。因为带符号的数字，其二进制最高位有一个数字为符号标志，负数为1</span><br><span class="line">function numOf1(n) &#123;</span><br><span class="line">  if(n.toString().indexOf(&#x27;.&#x27;) != -1) &#123;</span><br><span class="line">    return console.error(&#x27;n is not a int&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  let num = 0;</span><br><span class="line">  while(n) &#123;</span><br><span class="line">    if (n &amp; 1) &#123;</span><br><span class="line">      num ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    n = n &gt;&gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//改进：将1进行左移与i比较，这样来判断i二进制各个位是不是1</span><br><span class="line">//如果是32位存储，那么会循环32次</span><br><span class="line">function numOf1(n)&#123;</span><br><span class="line">  if(n.toString().indexOf(&#x27;.&#x27;) != -1) &#123;</span><br><span class="line">    return console.error(&#x27;n is not a int&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  let nums = 0;</span><br><span class="line">  let flag = 1;</span><br><span class="line">  while(flag) &#123;</span><br><span class="line">    if(flg &amp; n) &#123;</span><br><span class="line">      nums ++;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = flag &lt;&lt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//究极版：这个的原理是 一个二进制与其减去1的二进制进行位与运算后，产生的数与原先的二进制数相比，</span><br><span class="line">//从右边看会少去一个1。问题可以简化到二进制数有多少个1，就会进行以上多少次的循环，这个是效率最高的</span><br><span class="line">function numsOf1(n) &#123;</span><br><span class="line">  if(n.toString().indexOf(&#x27;.&#x27;) != -1) &#123;</span><br><span class="line">    return console.error(&#x27;n is not a int&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  let nums = 0;</span><br><span class="line">  while(n) &#123;</span><br><span class="line">    nums ++ ;</span><br><span class="line">    n = (n - 1) &amp; n;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、数值的整数次方"><a href="#9、数值的整数次方" class="headerlink" title="9、数值的整数次方"></a>9、数值的整数次方</h2><blockquote>
<p>题述：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。不使用库函数</p>
</blockquote>
<blockquote>
<p>思路：解题的第一反应是用for循环累加乘积，但可能忽略一些情况:输入的0值与负整数次幂。还有如何减少遍历次数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function power(base, exponent) &#123;</span><br><span class="line">  if (base == 0 &amp;&amp; exponent &lt; 0) &#123;</span><br><span class="line">    return console.error(&#x27;base should not be 0&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  let absExponent = exponent &lt; 0 ? -exponent : exponent;</span><br><span class="line">  let result = 1;</span><br><span class="line">  for (let i = 1; i &lt;= absExponent; i++) &#123;</span><br><span class="line">    result *= base;</span><br><span class="line">  &#125;</span><br><span class="line">  if (exponent &lt; 0) &#123;</span><br><span class="line">    result = 1 / result;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用递归减少乘积次数</span><br><span class="line">//使用位与运算可判断奇偶， 整数右移一位可取数除2的整数</span><br><span class="line">//可以通过互乘减少运算次数，如 数的8次方是数的4次幂的2次幂，数的4次幂是数的2次幂的2次幂 ...</span><br><span class="line">function power (base, exponent) &#123;</span><br><span class="line">  if (exponent == 0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (exponent == 1) &#123;</span><br><span class="line">    return base;</span><br><span class="line">  &#125;</span><br><span class="line">  let result = power(base, exponent &gt;&gt; 1);</span><br><span class="line">  result *= result;</span><br><span class="line">  //为奇数</span><br><span class="line">  if (exponent &amp; 1 == 1) &#123;</span><br><span class="line">    result *= base;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="10、删除链表节点"><a href="#10、删除链表节点" class="headerlink" title="10、删除链表节点"></a>10、删除链表节点</h2><blockquote>
<p>题述：定义一个删除节点的函数，传参为头结点与待删除节点，要求时间复杂度为O(1)。</p>
</blockquote>
<blockquote>
<p>思路：常规链表删除，会循环遍历到待删除节点，然后将其前一个节点指向其后一个节点。但是每次删除需要遍历,时间复杂度为O(n)。如果直接将待删除节点的下一个节点的值赋予给待删除节点，然后删除这个下一个节点，不是就相当于删除了么。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function deleteNode(headNode, deleteNode) &#123;</span><br><span class="line">  if (!headNode || !deleteNode) &#123;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  //删除的节点是头结点</span><br><span class="line">  if (headNode == deleteNode) &#123;</span><br><span class="line">    headNode = null;</span><br><span class="line">  &#125;</span><br><span class="line">  //删除的节点是尾节点</span><br><span class="line">  else if (deleteNode.next == null) &#123;</span><br><span class="line">    let node = headNode;</span><br><span class="line">    while(node.next != deleteNode) &#123;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node.next = null;</span><br><span class="line">    deleteNode = null;</span><br><span class="line">  &#125;</span><br><span class="line">  //删除的节点是中间节点</span><br><span class="line">  else &#123;</span><br><span class="line">    let nextNode = delete.next;</span><br><span class="line">    deleteNode.ele = nextNode.ele;</span><br><span class="line">    deleteNode.next = nextNode.next;</span><br><span class="line">    nextNode = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//整体时间：[(n-1)O(1) + O(n)]/n -&gt; O(1)</span><br></pre></td></tr></table></figure>


<h2 id="11、调整数组顺序"><a href="#11、调整数组顺序" class="headerlink" title="11、调整数组顺序"></a>11、调整数组顺序</h2><blockquote>
<p>题述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分。</p>
</blockquote>
<blockquote>
<p>思路：常规下可以遍历数组，如果数是偶数，可以将数拿出放到数组最后面，其后面的数字前移一位。同时也可以使用两个指针，一个指向数组头p1，一个指向数组尾p2,如果p1指向偶数，p2指向奇数，则双方对调,这样会出现4种情况，依次处理即可。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function reOrderArray(arr)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;;</span><br><span class="line">  let start = 0;</span><br><span class="line">  let end = arr.length - 1;</span><br><span class="line">  while(start &lt;= end) &#123;</span><br><span class="line">    let isOddS = arr[start] &amp; 1;</span><br><span class="line">    let isEvenE = !(arr[end] &amp; 1);</span><br><span class="line">   </span><br><span class="line">    if (isOddS &amp;&amp; !isEvenE) &#123;</span><br><span class="line">      start ++;</span><br><span class="line">    &#125; else if (isOddS &amp;&amp; isEvenE) &#123;</span><br><span class="line">      start ++;</span><br><span class="line">      end --;</span><br><span class="line">    &#125; else if(!isOddS &amp;&amp; isEvenE) &#123;</span><br><span class="line">      end --;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let temp = arr[start];</span><br><span class="line">      arr[start] = arr[end];</span><br><span class="line">      arr[end] = temp;</span><br><span class="line">      start ++ ;</span><br><span class="line">      end --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、链表中导数第k个结点"><a href="#12、链表中导数第k个结点" class="headerlink" title="12、链表中导数第k个结点"></a>12、链表中导数第k个结点</h2><blockquote>
<p>题述：输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<blockquote>
<p>思路：一般想法可以第一次遍历链表得到其长度，然后倒数第k个节点，那么则是第n+1-k个节点，然后第二次遍历链表即可得出，这样的缺点是需要遍历链表两次。遍历一次链表的做法：取两个指针，一个指针指向头节点，另外一个指针指向第k-1个节点，然后两个指针同时遍历，当第二个指针指向链表尾的时候，那么第一个指针会指向导数第k个节点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//注意边界情况：头结点为空，节点数小于k个，k不大于0</span><br><span class="line"></span><br><span class="line">function findKthToTial (head, k) &#123;</span><br><span class="line">  if (!head || k &lt;= 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  let startNode = head;</span><br><span class="line">  let endNode = head;</span><br><span class="line">  for (let i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">    if (!endNode.next) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    endNode = endNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  while(endNode.next) &#123;</span><br><span class="line">    startNode = startNode.next;</span><br><span class="line">    endNode = endNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return startNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13、反转链表"><a href="#13、反转链表" class="headerlink" title="13、反转链表"></a>13、反转链表</h2><blockquote>
<p>题述：输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<blockquote>
<p>思路：遍历链表，将下一个节点指向前一个节点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function resverseList(head) &#123;</span><br><span class="line">  if (!head) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  if (head.next == null) &#123;</span><br><span class="line">    return head;</span><br><span class="line">  &#125;</span><br><span class="line">  let node = head;</span><br><span class="line">  let nextNode = null;</span><br><span class="line">  let reservedNode = null;</span><br><span class="line">  let newHead = head;</span><br><span class="line">  while (node.next) &#123;</span><br><span class="line">    nextNode = node.next;</span><br><span class="line">    reservedNode = nextNode.next;</span><br><span class="line">    nextNode.next = newHead;</span><br><span class="line">    node.next = reservedNode;</span><br><span class="line">    newHead = nextNode;</span><br><span class="line">  &#125;</span><br><span class="line">  return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14、合并两个排序的链表"><a href="#14、合并两个排序的链表" class="headerlink" title="14、合并两个排序的链表"></a>14、合并两个排序的链表</h2><blockquote>
<p>题述：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</p>
</blockquote>
<blockquote>
<p>思路：依次去取两个链表的节点进行比较</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function mergeLinkList(head1, head2) &#123;</span><br><span class="line">  if (head1 == null) &#123;</span><br><span class="line">    return head2;</span><br><span class="line">  &#125;</span><br><span class="line">  if (head2 == null) &#123;</span><br><span class="line">    return head1;</span><br><span class="line">  &#125;</span><br><span class="line">  let mergeHead = null;</span><br><span class="line">  if (head1.ele &lt; head2.ele ) &#123;</span><br><span class="line">    mergeHead = head1;</span><br><span class="line">    mergeHead.next = mergeLinkList(haed1.next, head2);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mergeHead = head2;</span><br><span class="line">    mergeHead.next = mergeLinkList(head1, head2.next);</span><br><span class="line">  &#125;</span><br><span class="line">  return mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、二叉树的包含"><a href="#15、二叉树的包含" class="headerlink" title="15、二叉树的包含"></a>15、二叉树的包含</h2><blockquote>
<p>输入两颗二叉树A和B，判断B是不是A的子结构。</p>
</blockquote>
<blockquote>
<p>思路：先找A包含B的根节点，然后根据该节点比较左右子树</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//树节点定义</span><br><span class="line">function Node(ele) &#123;</span><br><span class="line">  this.ele = ele;</span><br><span class="line">  this.left = null;</span><br><span class="line">  this.right = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断树A有树B</span><br><span class="line">function hasSubTree(pRootA, pRootB) &#123;</span><br><span class="line">  if(pRootA == null || pRootB == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  let result = false;</span><br><span class="line">  if (pRootA.ele === pRootB.ele） &#123;</span><br><span class="line">    result = doesTreeAHaveTreeB(pRootA, pRootB);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!result) &#123;</span><br><span class="line">    result = hasSubTree(pRootA.left, pRootB);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!result) &#123;</span><br><span class="line">    result = hasSubTree(pRootA.right, pRootB)</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doesTreeAHaveTreeB(pRootA, pRootB) &#123;</span><br><span class="line">   //先要判断 pRootB</span><br><span class="line">  if (pRootB == null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pRootA == null) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  if (pRootA.ele != pRootB.ele) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return doesTreeAHaveTreeB(pRootA.left, pRootB.left) &amp;&amp; doesTreeAHaveTreeB(pRootA.right, pRootB.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="16、二叉树的镜像"><a href="#16、二叉树的镜像" class="headerlink" title="16、二叉树的镜像"></a>16、二叉树的镜像</h2><blockquote>
<p>题述：完成一个函数，输入一个二叉树，该函数输出它的镜像</p>
</blockquote>
<blockquote>
<p>思路：进行前序遍历，对于非叶子节点，有两个节点，则将其对换</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function mirror(root) &#123;</span><br><span class="line">  if (root == null) &#123;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let temp = root.left;</span><br><span class="line">  root.left = root.right;</span><br><span class="line">  root.right = temp;</span><br><span class="line"></span><br><span class="line">  if (root.left) &#123;</span><br><span class="line">    mirror(root.left);</span><br><span class="line">  &#125;</span><br><span class="line">  if (root.right) &#123;</span><br><span class="line">    mirror(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17、顺时针打印矩阵"><a href="#17、顺时针打印矩阵" class="headerlink" title="17、顺时针打印矩阵"></a>17、顺时针打印矩阵</h2><blockquote>
<p>题述：&#x2F;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字,例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。</p>
</blockquote>
<blockquote>
<p>思路：关键在于循环打印的条件在于 列数 &gt; 开始打印的列数x2 ，而且 行数 &gt; 开始打印的行数x2</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function printMatrix (arr) &#123;</span><br><span class="line">  if (!Array.isArray(arr)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  let rows = arr.length;</span><br><span class="line">  let columns = arr[0].length;</span><br><span class="line">  let start = 0;</span><br><span class="line">  while( columns &gt; start * 2 &amp;&amp; rows &gt; start * 2) &#123;</span><br><span class="line">    printMatrixInCicle(arr, columns, rows, start);</span><br><span class="line">    start ++ ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printMatrixInCicle (arr, columns, rows, start) &#123;</span><br><span class="line">  let endX = columns - 1 - start;</span><br><span class="line">  let endY = rows -1 - start;</span><br><span class="line">  //从左到右打印一行</span><br><span class="line">  for (let i = start; i &lt;= endX; ++i) &#123;</span><br><span class="line">    console.log(arr[start][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  //从上到下打印一列</span><br><span class="line">  if (start &lt; endY) &#123;</span><br><span class="line">    for (let i = start + 1; i &lt;= endY; ++ i) &#123;</span><br><span class="line">      console.log(arr[endY][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //从右向左打印一行</span><br><span class="line">  if (start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">    for (let i = endX -1 ; i &gt;= start; --i) &#123;</span><br><span class="line">      console.log(arr[endY][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //从下到上打印一行</span><br><span class="line">  if (start &lt; endX &amp;&amp; start &lt; endY - 1) &#123;</span><br><span class="line">    for (let i = endY -1 ; i &gt;= start + 1; --i) &#123;</span><br><span class="line">      console.log(arr[i][start]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>各位观众老爷，如果觉得可以的话，<a target="_blank" rel="noopener" href="https://github.com/BiaoZhiWang/biaozhiwang.github.io">biaozhiwang.github.io</a> star下</p>
</blockquote>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
        
    </div>
</body>



 	
</html>
